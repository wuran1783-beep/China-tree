<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>中国地图粒子圣诞树 • 手势终极版（电脑手势 + 手机触控双模式）</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap');
  body{margin:0;overflow:hidden;background:#000;font-family:'Cinzel';color:#d4af37;height:100vh}
  #c{position:fixed;inset:0}
  #ui{position:fixed;inset:0;pointer-events:none;z-index:10}
  #btns{position:fixed;top:20px;right:20px;display:flex;flex-direction:column;gap:15px;pointer-events:auto}
  .btn{background:rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.5);color:#d4af37;padding:12px 20px;border-radius:12px;font-size:15px;backdrop-filter:blur(8px);transition:.3s}
  .btn:hover{background:rgba(212,175,55,0.25);transform:scale(1.08);color:#fff}
  #loader{position:fixed;inset:0;background:#000;z-index:999;display:grid;place-items:center}
  .spinner{width:60px;height:60px;border:5px solid #d4af3711;border-top:5px solid #d4af37;border-radius:50%;animation:s 1s linear infinite}
  @keyframes s{to{transform:rotate(360deg)}}
  #cam{position:fixed;bottom:20px;right:20px;width:160px;height:120px;border:2px solid #d4af37;border-radius:8px;overflow:hidden;opacity:0;transition:opacity .8s;background:#000;z-index:20}
  #cam canvas{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
</style>
</head>
<body>

<div id="loader"><div class="spinner"></div></div>
<canvas id="c"></canvas>

<div id="ui">
  <div id="btns">
    <button class="btn" id="add>上传照片</button>
    <button class="btn" id="fs">全屏</button>
  </div>
  <input type="file" id="file" multiple accept="image/*" style="display:none">
</div>

<div id="cam"><canvas id="camcanvas"></canvas></div>

<audio loop id="m" preload="auto">
  <source src="https://actions.google.com/sounds/v1/holiday/we_wish_you_a_merry_christmas_instrumental.ogg">
</audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/environments/RoomEnvironment.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14"></script>

<script type="module">
const { FilesetResolver, HandLandmarker, DrawingUtils } = vision;

// ================ 中国地图轮廓 ================
const chinaPoly = [[[73.5,39.5],[75,40.8],[77,40.8],[79,41.5],[80.2,43],[80.2,45.5],[82.5,45.5],[85,47.8],[87.5,49.2],[90,49],[93,47],[96.5,47.8],[100,47.5],[101.5,46],[104.5,44.5],[107,44.2],[110,45],[111,43.5],[114,42.8],[116,43.5],[119,42.5],[121,43.5],[124,46.5],[126,45],[129,47.5],[131.5,48],[133,46],[131,44.5],[127,43],[125,40.5],[124,39],[122,37.5],[120,38],[118,38.8],[116,39.5],[114,38],[110,37.5],[108,35],[105,33],[103,32.5],[99,31.5],[97,29.5],[94,29.2],[91,29.8],[88,29.2],[86,28.2],[84,27.5],[82,27.8],[80,27.8],[78,27.5],[76,27],[74,27.2],[73.5,39.5]],[[121,25.3],[122,24.8],[122,24.3],[121.5,23.8],[120.8,22.8],[120.2,22.3],[121,22],[121.8,22.8],[122,23.8],[121.8,25],[121,25.3]],[[109.5,20.2],[110.2,19.8],[110,19.3],[109.5,18.8],[108.8,19],[108.6,19.6],[109,20.2],[109.5,20.2]]];
const polys = chinaPoly.map(p=>p.map(a=>[(a[0]-103)*0.24,(40-a[1])*0.46]));
function inChina(x,y){for(let p of polys){let i,j,c=0;for(i=0,j=p.length-1;i<p.length;j=i++){let a=p[i],b=p[j];if((a[1]>y)!=(b[1]>y)&&(x<(b[0]-a[0])*(y-a[1])/(b[1]-a[1]+1e-9)+a[0]))c^=1}return c}}
function randPos(){for(let i=0;i<999;i++){let x=Math.random()*12-6,y=Math.random()*12-6;if(inChina(x,y))return new THREE.Vector3(x,y+0.8,(Math.random()-0.5)*1.5)}return new THREE.Vector3(0,0,0)}

// ================ Three.js 场景 ================
let scene, camera, renderer, composer, group, star, particles = [], photos = [];
let mode = 'TREE', rotY = 0, rotX = 0.15, camZ = 55;
let handLandmarker = null, video = null, camCanvas = null, ctx = null;
const clock = new THREE.Clock();

initScene();
async function initScene(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(0x000);
  camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
  camera.position.z = camZ;
  renderer = new THREE.WebGLRenderer({canvas:document.getElementById('c'), antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth, innerHeight);

  const env = new RoomEnvironment();
  const pmrem = new THREE.PMREMGenerator(renderer);
  scene.environment = pmrem.fromScene(env).texture;
  scene.fog = new THREE.FogExp2(0x000, 0.012);

  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene,camera));
  const bloom = new UnrealBloomPass();
  bloom.strength = 1.8; bloom.radius = 0.6; bloom.threshold = 0.3;
  composer.addPass(bloom);

  group = new THREE.Group(); scene.add(group); group.rotation.x = 0.15;
  scene.add(new THREE.AmbientLight(0xffffff,0.4));
  const light = new THREE.PointLight(0xffd700,6,60); light.position.set(0,-10,12); group.add(light);

  // 1800个粒子组成中国地图圣诞树
  for(let i=0;i<1800;i++){
    const isBox = Math.random()<0.65;
    const geo = isBox ? new THREE.BoxGeometry(0.8,0.8,0.8) : new THREE.SphereGeometry(0.45,16,12);
    const mat = Math.random()<0.7 
      ? new THREE.MeshStandardMaterial({color:0xd4af37,metalness:1,roughness:0.2,emissive:0x885500})
      : new THREE.MeshStandardMaterial({color:0x00cc88,metalness:0.5,roughness:0.4});
    const m = new THREE.Mesh(geo, mat);
    m.scale.setScalar(0.4+Math.random()*0.6);
    group.add(m);
    particles.push({mesh:m, home:randPos(), offset:Math.random()*10});
  }

  // 树顶星星
  star = new THREE.Mesh(new THREE.OctahedronGeometry(2.2), new THREE.MeshStandardMaterial({color:0xffff88, emissive:0xffdd00, emissiveIntensity:6}));
  star.position.y = 16; group.add(star);

  // 背景星空
  const starsGeo = new THREE.BufferGeometry();
  const posArray = new Float32Array(9000);
  for(let i=0;i<3000;i++){
    const r = 120 + Math.random()*250;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    posArray[i*3]   = r*Math.sin(phi)*Math.cos(theta);
    posArray[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    posArray[i*3+2] = r*Math.cos(phi);
  }
  starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray,3));
  scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({size:1.8,color:0x88ccff,transparent:true,depthWrite:false})));

  // ================ 交互控制 ================
  // 1. 鼠标/触控备用方案（永远可用）
  let isMouseDown = false;
  const canvasEl = document.getElementById('c');
  canvasEl.addEventListener('mousedown', ()=>{isMouseDown=true; play();});
  canvasEl.addEventListener('mouseup mouseleave', ()=>{isMouseDown=false;});
  canvasEl.addEventListener('mousemove', e=>{
    if(isMouseDown){
      rotY += e.movementX * 0.008;
      rotX = THREE.MathUtils.clamp(rotX - e.movementY * 0.006, -0.6, 0.8);
    }
  });
  // 手机触控
  let touchMode = '';
  canvasEl.addEventListener('touchstart', e=>{
    if(e.touches.length===1) touchMode='rotate';
    if(e.touches.length===2) touchMode='zoom';
    play();
  },{passive:true});
  canvasEl.addEventListener('touchmove', e=>{
    if(e.touches.length===1){
      const t = e.touches[0];
      rotY += (t.clientX - innerWidth/2) * 0.002;
    }
    if(e.touches.length===2){
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.hypot(dx,dy);
      if(window.lastPinch) camZ = THREE.MathUtils.clamp(camZ + (window.lastPinch - dist)*0.08, 35, 100);
      window.lastPinch = dist;
    }
  },{passive:true});
  canvasEl.addEventListener('touchend',()=>{window.lastPinch=null;});

  // 2. 尝试加载手势识别（仅电脑+HTTPS有效，失败自动降级）
  if(location.protocol==='https:' || location.protocol==='file:'){
    try{
      const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
        runningMode: "VIDEO", numHands: 1
      });
      video = document.createElement('video');
      video.playsInline = true;
      const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});
      video.srcObject = stream; video.play();
      camCanvas = document.getElementById('camcanvas');
      ctx = camCanvas.getContext('2d');
      video.onloadedmetadata = ()=>{
        camCanvas.width = video.videoWidth; camCanvas.height = video.videoHeight;
        document.getElementById('cam').style.opacity = 1;
        requestAnimationFrame(predictHand);
      };
    }catch(e){console.log("手势识别不可用，自动使用触控方案");}
  }

  // 上传照片
  document.getElementById('add').onclick=()=>document.getElementById('file').click();
  document.getElementById('file').onchange=e=>{
    for(let f of e.target.files){
      const url = URL.createObjectURL(f);
      new THREE.TextureLoader().load(url, tex=>{
        const a = tex.image.width/tex.image.height;
        const s = 1.6;
        const w = a>1 ? s : s/a, h = a>1 ? s/a : s;
        const g = new THREE.Group();
        g.add(new THREE.Mesh(new THREE.BoxGeometry(w+0.25,h+0.25,0.1), new THREE.MeshStandardMaterial({color:0xd4af37,metalness:1})));
        const p = new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({map:tex}));
        p.position.z=0.06; g.add(p);
        group.add(g);
        particles.push({mesh:g, home:randPos(), offset:Math.random()*10});
      });
    }
  };

  // 全屏
  document.getElementById('fs').onclick=()=>document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen();

  // 隐藏 loading
  document.getElementById('loader').remove();
  animate();
}

// 手势识别循环
async function predictHand(){
  if(!handLandmarker || !video?.videoWidth){ requestAnimationFrame(predictHand); return; }
  const results = handLandmarker.detectForVideo(video, performance.now());
  ctx.save();
  ctx.clearRect(0,0,camCanvas.width,camCanvas.height);
  ctx.drawImage(video,0,0,camCanvas.width,camCanvas.height);
  if(results.landmarks?.[0]){
    const lm = results.landmarks[0];
    const wrist=lm[0], index=lm[8], middle=lm[12], palm=lm[9];
    const dIdx = Math.hypot(index.x-wrist.x, index.y-wrist.y);
    const dMid = Math.hypot(middle.x-wrist.x, middle.y-wrist.y);
    const open = [lm[8],lm[12],lm[16],lm[20]].reduce((s,p)=>s+Math.hypot(p.x-wrist.x,p.y-wrist.y),0)/4 > 0.32;
    const pointing = dIdx>0.12 && dMid<dIdx*0.6;

    if(pointing){
      mode = 'FOCUS';
      const photoObjs = particles.filter(p=>p.mesh.children?.[1]?.material?.map);
      if(photoObjs.length>0){
        const idx = (photos.indexOf(photoObjs[photos.length-1].mesh)+1) % photoObjs.length;
        photos.forEach(p=>p.mesh.scale.setScalar(1));
        photoObjs[idx].mesh.scale.setScalar(5);
        photoObjs[idx].mesh.lookAt(camera.position);
      }else{
        star.scale.setScalar(4);
      }
    }else{
      mode = open ? 'SCATTER' : 'TREE';
      if(open){
        const dx = palm.x - 0.5;
        rotY += dx * 0.15;
      }
      // 恢复缩放
      particles.forEach(p=>p.mesh.scale.setScalar(1));
      star.scale.setScalar(1);
    }
  }
  ctx.restore();
  requestAnimationFrame(predictHand);
}

function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // 手势优先，否则用鼠标/触控
  if(!handLandmarker){
    group.rotation.y = rotY;
    group.rotation.x = rotX;
    camera.position.z = camZ;
  }

  // 自动慢转
  if(mode==='TREE') group.rotation.y += 0.003;

  star.rotation.y = t*0.8;
  star.scale.setScalar(1.2 + Math.sin(t*3)*0.25);

  particles.forEach(p=>{
    const target = mode==='TREE' ? p.home : p.home.clone().multiplyScalar(3);
    p.mesh.position.lerp(target, 0.08);
    if(mode==='TREE') p.mesh.position.y += Math.sin(t*1.5 + p.offset)*0.2;
    p.mesh.rotation.y = t*0.5 + p.offset;
  });

  composer.render();
}

function play(){ document.getElementById('m').play().catch(()=>{}); }

window.onresize=()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
